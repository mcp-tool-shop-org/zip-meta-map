"""GitHub-native report and step summary generation."""

from __future__ import annotations


def build_step_summary(index: dict, project_name: str) -> str:
    """Build a GitHub Actions step summary from an index.

    Designed for GITHUB_STEP_SUMMARY. Concise and scannable,
    uses collapsible sections for detailed data.
    """
    files = index["files"]
    file_count = len(files)
    profile = index["profile"]
    generated_by = index["generated_by"]
    modules = index.get("modules", [])
    warnings = index.get("warnings", [])
    caps = index.get("capabilities", [])

    # Stats table
    caps_str = ", ".join(caps) if caps else "none"
    parts = [
        f"# zip-meta-map: {project_name}\n",
        "| Field | Value |",
        "|-------|-------|",
        f"| **Profile** | `{profile}` |",
        f"| **Files** | {file_count} |",
    ]
    if modules:
        parts.append(f"| **Modules** | {len(modules)} |")
    parts.append(f"| **Capabilities** | {caps_str} |")
    if warnings:
        parts.append(f"| **Warnings** | {len(warnings)} |")
    parts.append("")

    # Start here
    parts.append("## Start Here\n")
    file_map = {f["path"]: f for f in files}
    start_here = index["start_here"]
    if start_here:
        for i, path in enumerate(start_here[:10], 1):
            entry = file_map.get(path)
            reason = f" \u2014 {entry['reason']}" if entry and entry.get("reason") else ""
            parts.append(f"{i}. `{path}`{reason}")
    else:
        parts.append("_(none detected)_")
    parts.append("")

    # Plans table
    plans = index["plans"]
    if plans:
        parts.append("## Plans\n")
        parts.append("| Plan | Budget | Steps |")
        parts.append("|------|--------|------:|")
        for name, plan in plans.items():
            budget = plan.get("max_total_bytes", 0)
            budget_str = f"~{budget // 1024} KB" if budget else "\u2014"
            parts.append(f"| `{name}` | {budget_str} | {len(plan['steps'])} |")
        parts.append("")

    # Role distribution
    parts.append(_format_role_distribution(files))

    # Collapsible: warnings
    if warnings:
        parts.append("<details>")
        parts.append(f"<summary>Warnings ({len(warnings)})</summary>\n")
        for w in warnings:
            parts.append(f"- {w}")
        parts.append("\n</details>\n")

    # Collapsible: risk flags
    risk_section = _format_risk_breakdown(files)
    if risk_section:
        parts.append(risk_section)

    # Collapsible: chunk stats
    chunk_section = _format_chunk_stats(files)
    if chunk_section:
        parts.append(chunk_section)

    parts.append("---")
    parts.append(f"*Generated by {generated_by}*")

    return "\n".join(parts)


def build_report(index: dict, project_name: str) -> str:
    """Build a detailed standalone markdown report from an index.

    Designed for browsing inside GitHub PRs or as a release artifact.
    """
    files = index["files"]
    file_count = len(files)
    profile = index["profile"]
    generated_by = index["generated_by"]
    modules = index.get("modules", [])
    warnings = index.get("warnings", [])
    caps = index.get("capabilities", [])

    caps_str = ", ".join(caps) if caps else "none"
    risk_count = sum(1 for f in files if f.get("risk_flags"))

    parts = [
        f"# zip-meta-map Report: {project_name}\n",
        f"> Generated by {generated_by} | Profile: `{profile}` | {file_count} files\n",
        "## Summary\n",
        f"- **Profile**: `{profile}`",
        f"- **Files indexed**: {file_count}",
        f"- **Spec version**: {index['version']}",
        f"- **Capabilities**: {caps_str}",
    ]
    if warnings:
        parts.append(f"- **Warnings**: {len(warnings)}")
    if risk_count:
        parts.append(f"- **Risk-flagged files**: {risk_count}")
    parts.append("")

    # Start here
    parts.append("## Start Here\n")
    file_map = {f["path"]: f for f in files}
    start_here = index["start_here"]
    if start_here:
        for path in start_here:
            entry = file_map.get(path)
            reason = f" \u2014 {entry['reason']}" if entry and entry.get("reason") else ""
            parts.append(f"- `{path}`{reason}")
    else:
        parts.append("_(none detected)_")
    parts.append("")

    # Role distribution
    parts.append(_format_role_distribution(files))

    # Modules
    if modules:
        parts.append(_format_module_table(modules))

    # Plans (full descriptions)
    plans = index["plans"]
    if plans:
        parts.append("## Plans\n")
        for name, plan in plans.items():
            budget = plan.get("max_total_bytes", 0)
            budget_note = f" (budget: ~{budget // 1024} KB)" if budget else ""
            parts.append(f"### `{name}`{budget_note}\n")
            parts.append(f"{plan['description']}\n")
            for i, step in enumerate(plan["steps"], 1):
                parts.append(f"{i}. {step}")
            parts.append("")

    # File inventory
    parts.append(_format_file_table(files))

    # Risk analysis
    risk_section = _format_risk_breakdown(files, collapsible=False)
    if risk_section:
        parts.append(risk_section)

    # Warnings
    if warnings:
        parts.append("## Warnings\n")
        for w in warnings:
            parts.append(f"- {w}")
        parts.append("")

    parts.append("---")
    parts.append(f"\n*Generated by {generated_by}. The index is advisory, not authoritative.*")

    return "\n".join(parts)


def _format_role_distribution(files: list[dict]) -> str:
    """Format role distribution as a markdown table."""
    if not files:
        return ""

    role_counts: dict[str, int] = {}
    for f in files:
        role_counts[f["role"]] = role_counts.get(f["role"], 0) + 1

    total = len(files)
    lines = ["## Role Distribution\n"]
    lines.append("| Role | Count | % |")
    lines.append("|------|------:|---:|")
    for role, count in sorted(role_counts.items(), key=lambda x: -x[1]):
        pct = round(100 * count / total)
        lines.append(f"| {role} | {count} | {pct}% |")
    lines.append("")
    return "\n".join(lines)


def _format_file_table(files: list[dict], max_rows: int = 50) -> str:
    """Format file entries as a collapsible markdown table."""
    if not files:
        return ""

    lines = ["<details>"]
    lines.append(f"<summary>File Inventory ({len(files)} files)</summary>\n")
    lines.append("| Path | Size | Role | Confidence | Flags |")
    lines.append("|------|-----:|------|----------:|-------|")

    for f in files[:max_rows]:
        size = _human_size(f["size_bytes"])
        flags = ", ".join(f.get("risk_flags", []))
        lines.append(f"| `{f['path']}` | {size} | {f['role']} | {f['confidence']:.2f} | {flags} |")

    if len(files) > max_rows:
        lines.append(f"\n_...and {len(files) - max_rows} more files._")

    lines.append("\n</details>\n")
    return "\n".join(lines)


def _format_risk_breakdown(files: list[dict], collapsible: bool = True) -> str:
    """Format risk flag breakdown."""
    flag_counts: dict[str, int] = {}
    flagged_files: list[dict] = []
    for f in files:
        flags = f.get("risk_flags", [])
        if flags:
            flagged_files.append(f)
            for flag in flags:
                flag_counts[flag] = flag_counts.get(flag, 0) + 1

    if not flag_counts:
        return ""

    lines = []
    if collapsible:
        lines.append("<details>")
        lines.append(f"<summary>Risk Flags ({len(flagged_files)} files flagged)</summary>\n")
    else:
        lines.append(f"## Risk Analysis ({len(flagged_files)} files flagged)\n")

    lines.append("| Flag | Count |")
    lines.append("|------|------:|")
    for flag, count in sorted(flag_counts.items(), key=lambda x: -x[1]):
        lines.append(f"| {flag} | {count} |")
    lines.append("")

    lines.append("| File | Flags |")
    lines.append("|------|-------|")
    for f in flagged_files[:20]:
        flags = ", ".join(f.get("risk_flags", []))
        lines.append(f"| `{f['path']}` | {flags} |")
    if len(flagged_files) > 20:
        lines.append(f"\n_...and {len(flagged_files) - 20} more files._")

    if collapsible:
        lines.append("\n</details>\n")
    else:
        lines.append("")

    return "\n".join(lines)


def _format_chunk_stats(files: list[dict]) -> str:
    """Format chunking statistics as a collapsible section."""
    chunked = [f for f in files if f.get("chunks")]
    if not chunked:
        return ""

    total_chunks = sum(len(f["chunks"]) for f in chunked)
    avg = total_chunks / len(chunked) if chunked else 0

    lines = ["<details>"]
    lines.append(f"<summary>Chunk Stats ({len(chunked)} files chunked)</summary>\n")
    lines.append(f"- **Chunked files**: {len(chunked)}")
    lines.append(f"- **Total chunks**: {total_chunks}")
    lines.append(f"- **Avg chunks/file**: {avg:.1f}")
    lines.append("\n</details>\n")
    return "\n".join(lines)


def _format_module_table(modules: list[dict]) -> str:
    """Format module summaries as a markdown table."""
    lines = ["## Modules\n"]
    lines.append("| Module | Files | Size | Primary Roles | Summary |")
    lines.append("|--------|------:|-----:|---------------|---------|")
    for mod in modules:
        size = _human_size(mod.get("total_bytes", 0))
        roles = ", ".join(mod.get("primary_roles", []))
        summary = mod.get("summary", "")
        lines.append(f"| `{mod['path']}/` | {mod['file_count']} | {size} | {roles} | {summary} |")
    lines.append("")
    return "\n".join(lines)


def _human_size(n: int) -> str:
    """Format bytes as human-readable size."""
    if n < 1024:
        return f"{n} B"
    if n < 1024 * 1024:
        return f"{n / 1024:.1f} KB"
    return f"{n / (1024 * 1024):.1f} MB"
